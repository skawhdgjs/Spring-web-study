# 1부

1. 재빨리 테스트 하나 추가
2. 모든 테스트 실행후 새로 추가하는지 확인
3. 코드를 조금 바꾼다.
4. 모든 테스트를 실행하고 전부 성공하는지 확인
5. 리펙토링

## 주기

1. 작은 테스트를 하나 추가
2. 모든 테스트를 실행해서 테스트가 실패하는 것을 확인
3. 조금 수정한다
4. 모든 테스트를 실행해서 테스트가 성공하는 것을 확인하다.
5. 중복을 제거하기 위해 리펙토링을 한다. ( 중복을 제거하면 의존성도 제거된다.)
 

## ch02

작동하는 -> 깔끔한 코드를 만든다 (TDD)

작동하는 코드를 만든후 점진적으로 깔끔한 코드를 만든다.

## ch03 동치성

* Dollar 처럼 객체를 값처럼 쓸 수 있는데 이것을 *값 객체 패턴* 이라고 한다. 
* 값 객체는 생성자를 통해서 생성된후 에는 결코 변하지 않는다.
* 값 객체는 equals를 구현해야 한다.
* 또한 Dollar를 해시 테이블의 키로 쓸 생각이면 equal를 구현할때 hashcode를 같이 구현해야한다.

1. 바로 리팩토링을 하는 대신 테스트를 조금 더했다.
2. 두경우 (equal)를 수용할수 있도록 리팩토링했다.

## ch04 프라이버시

* 테스트를 향상시키기 위해서만 개발된 기능을 사용
* 두테스트가 동시에 실패하면 망한다는 점을 인식 하지만 계속 진행
* 테스트와 코드 사이의 결합도를 낮추기 위해, 테스트하는 객체의 새 기능을 사용했다.

## ch05 France

1. 테스트 작성
2. 컴파일되게하기
3. 실패하는지 확인하기 위해 실행
4. 실행하게 만듦
5. 중복제거 ( 속도를 위해 훌륭한 설계의 교릴를 어길 수 있고 적잘한 시기에 중복을 제거하자)

* 큰 테르스트를 공략 할수 없다 -> 그래서 진전을 나타낼 수 있는 조그만 테스트를 만듬
* 뻔뻔스럽게 중복을 만들고 조금만 고쳐서 테스트 작성
* 설상가상으로 모델 코드까지 도매금으로 복사하고 수정해서 테스트를 통과헀다.
* 중복이 사라지기전까지는 집에 가지 않겠다고 약속


## ch06 모두를 위한 평등

중복을 제거하기 위해 두 클래스의 공통 상위 클래스를 찾아낸다.

1. 공통된 코르르 첫번쨰 클래스에서 상위 클래스로 단계적으로 옮김
2. 두번쨰 클래스도 하위 클래스로 만듬
3. 불필요한 구현을 제거하기 전에 두 equals()구혀능ㄹ 일치시켰다.

## ch07 사과와 오렌지
서로 다른걸 비교할 수 없다.

1. 두개의 객체가 같다는 결함을 끄집어내서 테스했다.
2. 그럭저럭 봐줄만한 getClass로 테스트 통과
3. 아직은 바꿀만한 동기가 없으므로 놔두기로 한다.

## ch08 객체 만들기

* 동일한 times 의 변이형 메서드 서명부를 통일 시킴으로써 중복 제거를 향해감
* 최소한 메서드 선운부만이라도 공통 상위 클래스로 올김
* 팩토리 메서드를 도입하여 테스트 코드에서 컨크리트 하위 클래스의 존재 사실을 분리해냈다.
* 하위 클래스가 사라지면 몇몇 테스트는 불필요한 여분의 것이 된다는것을 인식, 그냥 놔둠

## ch09 우리가 사는 시간

* 큰 설계 아이디어를 다루다가 곤경에 빠짐, 더 작은 작업을 수행
* 다른 부분들을 호출자로 ( 펙토리 )로 옮김으로써 두 생성자를 일치시켰다.
* time가 펙토리 메서드를 사용하도록 만들기 위해 리펙토링을 잠시 중단.
* 비슷한 리펙토링을 franc, dollar에 적용
* 동일한 생성자들을 상위 클래스로 옮겼다.

## ch010 흥미로운 시간

* 두 times()를 일치시키기 위해 그메서드들이 호출하는 다른 메서드들을 인라인 시킨후 상수를 변수로 바꿔주었따.
* 단지 디버깅을 위해 toString()작성
* Franc 대신 money를 반환하는 변경을 시도한뒤 그것이 잘 작동하는지를 테스트가 말하도록했다.
* 실험해본걸 뒤로 물리고 또 다른 테스트를 작성

## ch011 모든 악의 근원

* 하위 클래스의 참조관계를 지우고 삭제했다.
* 기존의 소스 구조에서는 필요했지만 지금은 필요없는것을 지웠다.

## ch012 드디어 더하기

* 큰테스트를 작은 테스트로 줄여서 발전
* 필요한 계산에 대한 가능한 메타포들을 신중히 생각
* 새 메타포에 기반하여 기존의 테스트를 작성
* 테스트를 빠르게 컴파일
* 테스트 실행
* 진짜 구현을 만들기 위해 필요한 리팩토링을 약간의 전율과 함께 기대핬다.