## 프록시와 연관관계 관리

### 프록시와 즉시로딩, 지연로딩
객체는 객체 그래프로 연관된 객체 탐색 -> 객체가 데이터베이스에 저장되어 있으므로 연관된 객체를 탐색하기 어려움

**Jpa 구현체들은 이문제를 해결하기 위해 _프록시_ 기술을 사용한다**

* 프록시를 사용하면 처음부터 객체를 데이터베이스에서 조회하는게 아니고 실제 사용하는 시점에서 조회한다 ( 지연로딩 )
* 자주 함께 사용하는 객체들은 조인을 해서 함께 조회하는것이 효과적 ( 즉시 로딩 )


! 프록시

- 지연 로딩 기능을 사용하려면 실제 엔티티 객체 대신에 데이터베이스 조회를 지연할 수 있는 가짜 객체 

> 프록시의 기초

JPA에서 식별자로 엔티티 직접 하나를 조회할때 : EntityManager.find() -> 영속성 컨테이너에 없으면 DB에서 조회

JPA에서 엔티티를 실제 사용하는 시점까지 지연할떄 : EntityManager.getReference() 사용
( 이 메소드는 데이터베이스를 조회하지 않고 실제 엔티티 객체도 생성하지 않는 대신 프록시 객체를 반환한다 )

! 프록시의 특징 [소스](./ProxyExample.java)

프록시 클래스는 실제 클래스를 상속 받아서 만들어지므로 실제 클래스와 겉 모양이 같다.
따라서 사용하는 입장에서는 이것이 진짜인지 프록시 객체인지 신경쓰지 않아도 된다.

프록시 객체는 실제 객체에 대한 참조를 보관만하다 메소드를 호출하면 실제 객체 메소드를 호출한다. 

<hr>

### 영속성 전이와 고아객체

JPA는 연관된 객체를 함께 저장하거나 함께 삭제할 수 있는 영속성 전이와 고아 객체 제거라는 편리한 기능을 제공한다.

> 프록시 객체의 초기화

프록시 객체의 초기화: 프록시 객체는 실제 사용될때 데이터베이스를 조회해서 실제 엔티티 객체를 생성

`Member member = em.getReference(Member.class, "id")`
`member.getName()`

* 과정

1. 프록시 객체에 member.getName()을 호출해서 실제 데이터를 조회
2. 프록시 객체는 실제 인티티가 생성되어 있지 않으면 영속성 컨텍스트에 실제 엔티티 생성요청 (초기화)
3. 영속성 컨텍스트는 테이터베이스를 조회해서 실제 엔티티 객체를 생성한다.
4. 프록시 객체는 생성된 실제 인티티 객체를 참조를 Member target 멤버변수에 보관한다.
5. 프록시 객체는 실제 인티티 객체의 getName()을 호출해서 결과를 반환한다.

* 특징

1. 프록시 객체는 처음 사용할때 한번만 초기화 된다.
2. 프록시 객체를 초기화 한다고 프록시 객체가 실제 엔티티로 바뀌는 것은아님
3. 프록시 객체는 원본 엔티티를 상속받은 객체이므로 타입 체크 시에 주의해서 사용해아한다.
4. 영속성 컨텍스트에 찾는 인티티가 이미 있으면 테이터베이스를 조회할 필요가 없으므로 `em.getReference`를 호출해도 프록시가 아닌 실제 엔티티를 반환
5. 초기화는 영속성 컨텍스트의 도움을 받아야한다. 따라서 준영속 상태의 프록시를 초기화하면 문제가 발생
5.1 준영속 상태의 프록시를 초기화 하면 provider 따라 다른 에러가 날수 있다.

#### 프록시와 식별자

엔티티를 프록시로 조ㅚ할때 식별자(pK)값도 파라미터로 전달:: 프록시 객체는 이 식별자 값을 보관한다.

! 프록시 객체는 식별자 값을 가지고 있으므로 식별자 값을 조회하는 tea.getId()를 호출해도 프록시를 초기화 하지 않는다.
( 단 엔티티 접근 방식을 @Access(AccessType.PROPERTY)로 설정한 경웽만 초기화 하지 않는다 )

* 연관관계를 설정할 때는 식별자 값만 사용하므로 데이터베이스 접근 횟수를 줄일 수 있다. 
엔티티 접근 방식을 필드로 설정해도 프록시를 초기화 하지 않는다.

```java
EntityMamanger em = new EmtityManager();
Member member = em.find(Member.class, "member1")
Team team = em.getReference(Team.class , "team1")
member.setTeam(team);
```

#### 프록시 확인
JPA가 제공하는 PersistenceUnitUtil.isLoaded(Object entity) 메소드를 사용하면
프록시 인스턴스의 초기화 여부를 확인 가능. javassist는 프록시 메소드

<hr>

### 즉시 로딩과 지연 로딩

프록시 객체는 주로 연관된 엔티티를 지연 로딩할 때 사용한다. (fetchType은 아래 2개 밖에 없다.)

* 즉시로딩: 엔티티를 조회할 떄 연관된 엔티티도 함께 조회한다. 설정방법 @ManyToOne(fetch = FetchType.EAGER), 
즉시 로딩을 최적화하기 위해 쿼리2번이 아니라 가능하면 *조인 쿼리*를 사용한다.
(조인 쿼리시 식별자값이 null일 수 있기 떄문에 LEFT OUTER JOIN을 사용, @joinColum에 nullable을 false로 지정하면
JPA는 성능상더 유리한 내부조인을 사용하게 된다. 또는 @ManyToOne.optional = false를 사용한면 된다)  

* 지연로딩: 연관된 엔티티를 실제 사용할 때 조회 설정방법 @ManyToOne(fetch = FetchType.LAZY) or @ManyToOne.Optional = true

### 프록시와 컬렉션 래퍼

Hibernate는 엔티티를 영속 상태로 만들 때 엔티티에 컬렉션이 있으면 컬렉션을 추적하고 관리할 목적으로
원본 컬렉션을 하이버네트가 제공하는 내장 컬렉션으로 변경:: 컬렉션 래퍼

* 주문내역같은 컬랙션은 컬렉션 래퍼가 지연 로딩을 처리해준다.
ex) `member.getOrders().get(0)` 처럼 컬렉션에서 실제 데이터를 조회할 때 데이터베이스를 조회해서 초기화한다.

### JPA 기본 페치 전략

JPA는 연관된 엔티티가 하나면 즉시 로딩, 컬렉션이면 지연로딩을 사용한다. 컬렉션을 로딩하는 것은 비용이 많이 들고
잘못하면 너무 많은 데이터를 로딩할 수 있기 때문이다. 

! 추천: 모든 연관관계에 지연로딩을 사용하고, 개발이 어느정도 완료단계에 왔을때 필요한 부분만 즉시로딩으로 변경,
직접 SQL을 사용하면 이러한 유연한 최적화가 어렵다.

### FetchType.EAGER 사용시 주의점

1. 컬렉션을 하나 이상 즉시 로딩하는 것은 권장하지않는다. 데이터 베이스에서 컬렉션조인을 일대다 조인이고 서로 다른 컬렉션을 2개 이상 조인할 때
엄청난 수의 Row증가가 발생한다.

2. 컬렉션 즉시 로딩은 항상 OUTER JOIN을 사용한다. 일대다 관계일때 반대펴넹 회원이 한명도 없는 팀을 내부 조인하면 팀까지 조회되지 않는 문제가 있어
무조건 OUTER JOIN을 사용한다. 

### CASCADE

특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶으면 영속성 전이 기능을 사용하면 된다.
JPA는 CASCADE 옵셕으로 영속성 전이를 제공한다. 

JPA에서 엔티티를 저장ㅎ라때 연관된 모든 엔티티는 영속 상태여야 한다. 
따라서 부모를 영속화할떄 연관된 자식들도 함꼐 영속화 하기 위해선

`cascade = CascadeType.PERSIST`를 사용한다.

* 영속성 전이는 연관관계를 매핑하는 것과는 아무런 관련이 없기 때문에 관계를 추가하고 영속 상태로 만든다.


#### CASCADE Remove
부모와 자식 엔티티를 모두 제거하려면 각각의 엔티티를 하나씩 제거해야한다.
그러나 영속성 진이 `CascadeType.REMOVE`를 설정하면 자식 엔티티도 함꼐 산제 된다.

> CASCADE는 여러 속성을 같이 사용할수 있다. cascade = {CascadeType.PERSISET, CascadeType.REMOVE}

### 고아 객체

JPA는 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능을 제공 이것을 고아 객체 제거라 한다.
부모 엔티티의 컬렉션에서 자식 엔티티의 참조만 제거하면 자식 엔티티가 자동 삭제
`OneToMany.orphanRemoval=true , OneToOne.orphanReomoval` 참조가 제거된 엔티티는 다른 곳에서 참조하지 
않는 고아 객체로 보고 삭제하는 기능이기때문에 삭제한 엔티티를 다른 곳에서도 참조한다면 문제가 생길수있다 일대N관계에서만 적용 가능하다.
(= CascadeType.REMOVE)와 같다.

### 영속성 전이 + 고아 객체, 생명주기
CascadeType.ALL + orphanRemoval = true을 동시에 사용하면 부모 엔티티를 통해서 자식의 생명주기를 관리하게 된다.

<hr>

## 정리

1. JPA 구현체들은 객체 그래프를 마음껏 탐색할 수 있도록 지원, 이때 프록시 기술을 사용한다.
2. 객체를 조회할 때 연관된 객체를 즉시 로딩하는 방버을 즉시 로딩, 지연해서 로딩하는 방법을 지연 로딩
3. 객체를 저장하거나 삭제할때 연관된 객체도 함꼐 저장하거나 삭제할 수 있는데 이것을 영속성 전이라고 한다.
4. 부모 엔티티와의 관계가 끊어진 자식 엔티티를 자동으로 삭제하려면 고아 객체 기능을 사용하면 된다.

